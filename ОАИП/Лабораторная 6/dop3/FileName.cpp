#include <iostream>
using namespace std;

// Определяем структуру для элемента списка
struct Node {
    int data; // Хранится номер человека
    Node* next; // Указатель на следующий элемент списка
    Node* prev; // Указатель на предыдущий элемент списка
};

// Функция добавления элемента в конец списка
void push(Node** head_ref, int data) {
    Node* new_node = new Node; // Выделяем память под новый элемент списка
    new_node->data = data; // Заполняем данные нового элемента
    new_node->next = *head_ref; // Указатель на следующий элемент указывает на голову списка
    new_node->prev = (*head_ref)->prev; // Указатель на предыдущий элемент указывает на последний элемент списка
    (*head_ref)->prev->next = new_node; // Указываем последнему элементу списка, что следующий элемент - новый элемент
    (*head_ref)->prev = new_node; // Указываем, что последний элемент списка - новый элемент
}

// Функция удаления элемента из списка
void deleteNode(Node** head_ref, Node* del) {
    // Если элемент, который нужно удалить - голова списка
    if (*head_ref == del) {
        *head_ref = del->next; // Указываем, что голова списка - следующий элемент после удаляемого
    }
    // Обновляем указатели на соседние элементы
    if (del->next != NULL) {
        del->next->prev = del->prev;
    }
    if (del->prev != NULL) {
        del->prev->next = del->next;
    }
    // Освобождаем память, занятую элементом, который нужно удалить
    delete del;
}

// Функция, которая возвращает индекс удаляемого элемента
int josephus(int n, int k) {
    Node* head = new Node; // Создаем голову списка
    head->data = 1; // Первый элемент списка - первый человек в круге
    head->next = head->prev = head; // Список закольцован на самого себя
    // Заполняем список оставшимися людьми
    for (int i = 2; i <= n; i++) {
        push(&head, i);
    }
    Node* curr = head; // Текущий элемент списка
    int count = 1; // Счетчик удаленных элементов
    while (curr->next != curr) { // Пока в списке остался более 1 элемента
        if (count == k) { // Если достигнуто k-ое удаление
            Node* temp = curr; // Сохраняем указатель на текущий элемент
            curr = curr->next; // Перемещаем указатель на следующий элемент
            count = 1; // Сбрасываем счетчик
            deleteNode(&head, temp); // Удаляем сохраненный элемент
        }
        else { // Иначе перемещаем указатель на следующий элемент списка и увеличиваем счетчик
            curr = curr->next;
            count++;
        }
    }
    int survivor = curr->data; // Номер оставшегося человека
    delete curr; // Освобождаем память, занятую последним элементом списка
    return survivor;
}

int main() {
    setlocale(LC_ALL, "RUS");
    int n = 40; // Количество людей в круге
    int k = 6; // Каждый k-ый будет удален
    int survivor = josephus(n, k); // Находим номер оставшегося человека
    cout << "Оставшийся человек: " << survivor << endl; // Выводим результат
    return 0;
}



//Краткое описание алгоритма :
//1. Создаем двусвязный список и заполняем его людьми.
//2. Пока в списке остался более 1 элемента, проходим по списку и удаляем каждый k - ый элемент.
//3. После удаления последнего элемента в списке остается только один элемент, номер которого и будет ответом.
//4. Освобождаем память, занятую списком.
